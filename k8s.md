# Docker #
#### $ docker build " 我的镜像 "
#### $ docker run " 我的镜像 "
## Docker 项目在短时间内迅速崛起的三个重要原因 ##
如何让开发者把应用部署在我的项目上。
1. Docker 镜像通过技术手段解决了 PaaS 的根本性问题：打包应用改成打包镜像
2. Docker 容器同开发者之间有着与生俱来的密切关系；
3. PaaS 概念已经深入人心的完美契机。
## 容器 ##
容器技术的兴起源于 PaaS 技术的普及；
Docker 公司发布的 Docker 项目具有里程碑式的意义；
Docker 项目通过“容器镜像”，解决了应用打包这个根本性难题。
容器其实是一种沙盒技术。顾名思义，沙盒就是能够像一个集装箱一样，把你的应用“装”起来的技术。这
样，应用与应用之间，就因为有了边界而不至于相互干扰；而被装进集装箱的应用，也可以
被方便地搬来搬去，这不就是 PaaS 最理想的状态嘛。

#####容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个“边界”。

####容器，其实是一种特殊的进程而已。

“敏捷”和“高性能”是容器相较于虚拟机最大的优势，也是它能够在 PaaS 这
种更细粒度的资源管理平台上大行其道的重要原因。

####Linux Cgroups 的全称是 Linux Control Group。它最主要的作用，就是限制一个进程
组能够使用的资源上限，包括 CPU、内存、磁盘、网络带宽等等。

这是因为容器本身的设计，就是希望####容器和应用能够同生命周期

一个正在运行的 Docker 容器，其实就是一个启用了
多个 Linux Namespace 的应用进程，而这个进程能够使用的资源量，则受 Cgroups 配置
的限制，容器是一个“单进程”模型。

Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上
一组资源限制文件的组合。

容器本身的设计，就是希望容器和应用能够同生命周期

####这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字，叫作：rootfs（根文件系统）。
所以，一个最常见的 rootfs，或者说容器镜像，会包括如下所示的一些目录和文件，比如
/bin，/etc，/proc 等等：
 复制代码
1 $ ls /
2 bin dev etc home lib lib64 mnt opt proc root run sbin sys tmp usr var
而你进入容器之后执行的 /bin/bash，就是 /bin 目录下的可执行文件，与宿主机的
/bin/bash 完全不同。
现在，你应该可以理解，对 Docker 项目来说，它最核心的原理实际上就是为待创建的用户进程：
1. 启用 Linux Namespace 配置；
2. 设置指定的 Cgroups 参数；
3. 切换进程的根目录（Change Root）。

正是由于 rootfs 的存在，容器才有了一个被反复宣传至今的重要特性：一致性。
由于 rootfs 里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。

需要明确的是，rootfs 只是一个操作系统所包含的文件、配置和目录，并不包括操作系统内核。在 Linux 操作系统中，这两部分是分开存放的，操作系统只有在开机启动时
才会加载指定版本的内核镜像。

容器的 rootfs 由如下图所示的三部分组成：
![image](https://github.com/rita-zu/k8s/assets/153474666/19620014-233b-44c6-93ca-c9f164a95a7b)


